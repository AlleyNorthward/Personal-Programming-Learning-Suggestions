&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.11.26 20:42  
&emsp;&emsp;"母球所到之处, 即是心中所想"  
1</br>

# 简介 
自从今年八月份, 将自己的问题完全分析过后, 也学到了很多东西. 但不行的是, 就像软件需要更新一样, 应对自己的各种心理情况的方法, 也需要随时更新. 我期望能按部就班地进行下去, 但现实却恰恰相反, 总会有东西阻碍着你. 所以这里呢, 就是记录所有阻碍着我的"东西", 供后续参考. 要是不记录下来的话, 过了一段时间后又忘了, 但当再次遇到类似问题时, 却又陷入束手无策的状态, 这必然是不应该的.  
下面的第一个内容, 是我前段时间反思的, 不过写在了别的地方, 我便拿了过来, 方便汇总整理.  

- [个人反思](#个人反思)
- [2025.11.26](#20251126)
    - [反馈](#00反馈)
- [2025.12.05](#20251205)
    - [十天近况](#十天近况)
    - [原因](#原因)
    - [反思](#反思)
    - [反馈](#01反馈)
    - [再反馈](#再反馈)
    - [再再反馈](#再再反馈)
    - [再再再反馈](#再再再反馈)
- [2025.12.22](#20251222)

## 个人反思
这段时间, 一直在配置`neovim`, 差不多配置了`10`天左右吧, 到现在小有成型. 其实前面的也都还好, 语言不同, 插件不会配置, 这些问题也都慢慢解决了. 但最让我头疼的是`lsp`的配置. 确实十分头疼.  
可能比较简单的部分, 问问`ai`就很容易解决, 但是, 如果只是单纯地问`ai`, 一点也都不思考的话, 到后面很难自定义修改, 导致后面的路越走越窄, 最后就陷入"错了问`ai`, 仍错接着问`ai`"的循环中, 最后都无法解决的痛苦之中.  
对于我自己呢, 靠着`ai`能快速学习很多东西, 下面罗列一些吧. `Ai`的使用, `vim`等的基础配置, 嵌入式理解, `C`指针, `C++`面向对象深入, 数据库理解等等. 对于`Ai`, 是纯软件, 只不过是一些简单的快捷键操作. 语言方面, `C`和`C++`是之前学过的, 但是理解不深入, 后续借助`Ai`以及自己对`Python`的理解, 很容易地移植到这两个语言中. 对于嵌入式, 数据库等, 则是自己不明白的地方问`ai`, 最后总会搞懂, 建立自己的心理表征. 它们几乎都会有资料查询, 而且配置代码不多(`C`和`C++`除外).  
但配置`neovim/vim`则完全不同. 新的语言, `lua/vimscript`, 不熟悉的机制和接口, 以及不熟练的`vim`操作...  
当然, 两个月前第一次配置, 确实是十分头疼, 最终还是选择了放弃, 虽然用着`vscode`, 但强迫自己放弃鼠标, 改用`vscode`中的`vim`操作, 练习了两个月. 两个月后, 时机成熟, 便打算移植到`neovim`中来.  
前面顺风顺水, 有着别人的代码参考. `lua`语言跟`python`很像, 也能迅速学习. 而且这个时候`ai`用的也比较少, 因为主要写的是映射相关的代码, `neovim`接口方面也是比较固定的, 很好更改. 等后续配置`lsp`的时候, 就不行了. 因为参考文档代码是`22`年的, 而最近`neovim`的`lsp`更新了, 接口也更新了, 所以无法适配. 问`ai`的话, 它总会拿着老的`lsp`接口回答, 粘贴上的话, 毫无疑问, 都是报错的.  
那段时间的心理很复杂. 一方面, 能自己写`lua`配置`neovim`的按键映射了, 但也是仅限于此, 因为其它接口都不清楚, 而且对于`neovim`的实现机理也不明白, 整体仍呈现黑盒状态. 另一方面, `neovim`的文档很多很长, 我不知道哪些对我有用, 哪些对我没用, 怎么看, 怎么用, 都不清楚. 所以, 最后还是处于初始阶段, 一直整理代码架构(不过有一说一, 架构整理好了, 后续写代码真的十分清晰).  
再详细描述一下当时的状态吧, 供后续参考(之前在学嵌入式时, 也有过这种迷茫状态, 但最终还是克服了. 什么状态呢?怎么克服的呢?我也都忘记了, 所以这里记录一下十分有必要). 对自己具备快速学习某种语言的能力而高兴, 但是, 缺少独立开发的能力. 欠缺读文档的能力. 过于依赖`ai`, 平时虽然能解决大部分问题, 也能学到很多东西, 但是, 像这种接口, 配置方面的问题, 如果它解决不了的话, 手足无措. `github`下方的`README`, 不会主动去看, 有问题不是选择看`README`, 而是选择去问`ai`. 有些`csdn`, `b`站视频, 其实很不错, 虽然不能直接解决问题, 但可以提供代码参考. 当时就不会选择这么做, 第一选择还是问`ai`.  
最后怎么解决的呢? 我觉得, 最后还是稍微深入了解了一下`neovim`, 注意, 也只是浅浅地了解了一下, 边足以建立个人认识. 怎么弄的呢?  
其实也是分析了很久. 分析了个人学习语言和库的不同, 应该在`lua`文档哪里, 这里不再重复. 最后发现, 正常学习, 总会有反馈(比如嵌入式, 硬件反馈, `manim`则是视频反馈), 来论证你做的是否正确. 而有些库的学习, 是一个黑盒, 缺少反馈. 比如配置`neovim`, 开始容易, 是因为终端界面反馈, 说明你做的没问题, 按键映射反馈, 也说明你做的没问题. 可是到了`lsp`, 一直报错, 缺少反馈, 就很头疼, 于是便陷入循环问`ai`的过程中了. 另外, 还有项目编写能力. 别人写好的库, 其实就是一个非常好的`lua`和`neovim`接口配合过程代码集合. 但是总是害怕去看, 因为太长, 太多, 结构太复杂(因为有时候我自己编写的代码, 设计的结构, 个人必然十分清晰, 但是外人来看, 很难看懂. 即使说明了结构, 我觉得他或许总会纠结于某个函数, 某个变量什么意思, 而一直困惑).  
最后, 我打算去复刻一个插件. 这个插件就是`nvim-tree`. 感觉可能很复杂, 但是配合着`ai`, 我迅速理解了底层实现原理, 并且学了部分`neovim`的接口. 恍然大悟.  
再此基础上, 再去配置`lsp`, 就好很多了. 因为我清楚了是什么, 而且了解了部分的`neovim`的接口, 所以就愿意主动去看文档了, 查看不同, 最后, 配置了`lua`的`lsp`, 然后`python`的`lsp`, `c++`的`lsp`(虽然说着很简单, 但是, 配置`lsp`还是不好配置啊), 解决了很多很多问题. 而且对后续环境自动化搭建有了一定的设想.  
不论怎么说, 加油吧!!  

## 2025/11/26

今天的心情, 整体上来说, 十分地乱. 没有目标, 没有目的. 什么都需要做, 什么也都想做, 但就是提不起兴趣来. 昨天其实也打算好了, 今天要做什么, 虽然快速过了一遍, 但被其他东西压着身, 导致这些事一点也没干....  下面就罗列一下待做的事吧, 包括老师布置的任务, 但大部分, 其实还是我自己内心构造出来的, 不做也没事, 但我一直想做, 却又一直拖着...  

- 数据库的`ER`图, 周五(后天交), 昨天(周二)打算今天(周三)看`linux`操作系统内核的书, 所以`ER`图放到明天(周四)弄. 
- 数据库的结课实验前端部分整体还没有思路弄, 后端操作部分也没有思路弄.
- 嵌入式实验(总共十一篇)还没有写, 虽然之前深入学了, 有很多底层内容, 可以直接放入, 但是, 现在不想写...
- `web`实验没写. 虽然很简单, 但是现在也不想写, 因为没说截止日期. 
- 人工智能实验也没写. 算法代码虽然都弄完了, 但是不想写...
- 想了一下, 实验报告不想写的原因, 可能是因为存在数据库这座大山, 导致自己不太想去做. 
- 今天看了操作系统内核, 里面有些知识跟嵌入式相关, 一看就懂, 有些是汇编等其它我不太了解的东西, 比较想去了解, 弄清楚操作系统底层的实现原理, 为后续算法学习, 构建我自己的数学相关软件做好铺垫.  
- 今天上午几个小时过了一遍那本书, 下午的时候, 又配置了`linux`部分`neovim`的运行代码. 没想到几十分钟就搞定了. 后来呢, 发现`linux`端写代码太舒服了, 又有了将我的电脑更换为`linux`操作系统的想法. 这样写代码一定非常舒服. 可是又有很多的顾虑, 最主要的是, 嵌入式代码烧录, 如何从`linux`端烧录到`stm32`呢? 我没有查, 但感觉环境配置就需要很多的时间. 最后, 还是有想分析`linux`内核的想法, 这样需要做一下操作系统的相关实验. 我是很想做的, 但是, 上面有很多事情压着, 我也不敢去做. 
- 还有人工智能等相关的数学, 我自己还想再深入看看, 分析一下的...

总体来看, 差不多就这么多吧. 上面其实不仅是待做的事情, 也将我自己内心的顾虑说了出来. 但还有没说完全, 下面再来说说此时内心的顾虑吧. 

- 昨天配置好`c++ lsp`相关的东西, 脑海里一直在思考着自动化:如何自动分析出项目中的`C++`相关库路径, 并放到`.json`呢? 今天弄好`linux`后, 想着完全转为`linux`也很不错, 但是`powershell`相关自动化配置语言, 是否还需要学习呢? 
- 另外, `c++`相关配置的`cmake`语法, 也需要学习的. 
- 想重新深入分析一下算法, 数据结构, 但现实却是不允许啊. 
- `web`什么的也都想弄, 但是被上面的东西压着, 也没动力进行下一步...
- 另外, 今天弄了`linux`, 发现, 很多命令行都是`ai`的, 直接`copy`就可以, 但是, 却没有在脑海里有任何停留. 

或许说完了. 什么感觉都能做, 最后什么也没有做. 本来之前想着配置好`lsp`, 能专心写代码, 但昨天弄好之后, 发现配置也并不容易. 而且, 我只是配置好了`python lua c/c++`, 还有`java`等语言没有配置好. 现在能写写代码了, 但是, 却力不从心, 什么都不想写.  

带着这种消极的心态, 我写下了上面的问题. 下面应该来看, 如何解决了. 不过说实话, 我确实也没好的解决方法, 要是有好的解决方法, 也没必要再写这些东西了... 怎么感觉写完上面的这些后, 更加消极了, 哈哈...  

仔细回顾一下, 嵌入式深入学习, 其实也就一个多月的时间, 能明白很多很多很多东西. 为什么呢? 但其实那段时间里, 也曾盲目过, 但是没有及时记录下来. 我也忘了什么原因了. 最后, 应该还是面向对象吧, 激励着我去深入分析, 有很多不懂的, 问了`ai`, 大部分其实都能解决. 有些语言问题, 也会在重复地编写代码之下, 能够熟练掌握并应用.  
另外, 之前在`lua`中也分析到了, 总会有可视化的反馈给你, 正向激励着你努力奋进的.  
所以, 我们当下, 先抛去所有事物, 只去看最关键的部分, 卸下重担, 只专注于那一个部分即可. 那么目前最关键的那部分是什么呢? 数据库.像这种实验报告的东西, 又不是非得这周交, 似乎还有两三周的时间去做写, 没必要太过于着急. 那么这段时间, 我们就以数据库为中心专注学习吧, 摒弃一切杂念, 就像专注深入嵌入式那样深入数据库, 体会其中的乐趣, 不好吗? 后续开发准备肯定也是需要`web`相关知识的, 我们也可以用数据库这部分实现的东西, 去准备`web`的结课报告, 不也是一件很好的事吗?  

### 00反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.11.26 23:13  
管它呢, 焦虑什么啊, 干就完了. 刚才弄了弄`ER`图, 其实也就那样. 其它的那些东西不也就那样吗? 很多东西, 你不去做, 看起来都非常庞大, 但凡做做, 会发现, 也就那样. 实验报告虽然很多, 但是实验都做完了, 代码也都有, 只是报告没写而已, 平时的时候写写, 不也早就会完成吗? 

## 2025/12/05
&emsp;&emsp;@author 巷北
&emsp;&emsp;@time 2025.12.05 17:11  

今天的心情(昨天的吧?)感觉也没那么糟糕, 可能有了上面的参考(反馈?分析?)吧, 这样后续心情不好(学习编程层面的), 也能有例子看看, 缓解一下. 想了想, 还是来记录一下心情不好的原因及状态, 当然, 也有解决方案, 仍能提供后续参考. 不过, 刚才点进来, 又看了看上面写的内容, 确实不错, 那不如直接将这十天(`11.26 - 12.05`), 干的事, 简单说说吧, 主要是挑些重要的, 印象深刻的说说吧.  

### 十天近况

首先要说明, 这个文档, 目的是记录学习编程时遇到的挫折, 受挫, 心情不好, 等等可能导致效率低下的情形/情况/情境, 以及记录解决这些问题/重振士气时的方案/策略/选择. 所以, 这并不会像日记/周记等, 定时记录自己表现的文档. 每次写什么, 都看当时的心情, 有时, 可能会因为没有头绪, 而感到低落, 那么写的风格会比较悲观; 有时找到了解决方案, 那么风格会比较开朗. 但是不论怎么, 以后可能不会出现这种"十天近况"的周记似的分段, 因为下一次写, 我也不知道会是什么时候, 下周? 一个月后? 都不一定. 所以, 一切都存在未知性, 当时的心情如何, 我也不知道, 全凭感觉, 完全随机, 格式不固定(但是仍会标记时间).  

- 看了`linux`内核相关书籍, 里面有关于`linus`编写`linux`时的一些情况. 首先, 他有一台计算机(裸机, 无操作系统), 其次, 他有编写代码的环境(能编写代码, 编译代码, 并且能将相关代码放到计算机中运行的环境), 最重要的是, 编写操作系统内核代码, 计算机端能有反馈(猜测的, 具体如何, 我也不清楚, 但肯定有反馈的方式), 当然, 还有开源的操作系统`Minix`, 以及`minix`的相关书籍. 除了这些实体东西外, 还有内驱力: 个人兴趣(兴趣驱动), 以及解决个人实际问题(问题驱动).  
    - 上面的内容, 总结如下:
        - 良好的编写代码/运行代码的环境.
        - 良好的可视化的反馈.
        - 可参考的开源代码/书籍.
        - 兴趣驱动.
        - 问题驱动.
    - 当然, 这些内容, 肯定是结合我自身学习情况总结的. 可能并不完全, 但对我自己而言, 足够了. 当然, 我们也能在`linus`开发`linux`内核时, 看到上面总结的缩影(其实就是我一开始写出来的, 哈哈). 
    - 这五条并不是都要在一起的, 比如问题驱动, 对于个人而言, 尤其是大学时期, 接受被动教育学习, 较难带着问题思考. 但是, 历史上, 很多东西的发展, 离不开问题的驱动. 不过, 学习编程时(我自己), 总能看到上面的影子, 从而能给予良好的反馈.
    - 另外, 当今是`ai`时代, 跟`linus`开发时的学习环境还是有很大的不同的. 那个时代, 身处欧洲, 不知道他是怎么获取信息的, 毕竟信息化时代还未普及全球. 而如今的我们, 可以向`ai`问各种各样的内容, 打破信息壁垒. 不过, 当时的`os`, 存在很多问题的, 这些问题, 也驱动着`linus`去解决. 现在呢, `os`发展较为成熟, 我们也只能从课本上学习, 或者实验中学习(可是, 实验中学习, 也是被动学习, 你是抱着我去完成这个实验的思想去做实验呢, 还是抱着开发`os`的思想去做实验呢?), 收效极为有限. 
    - 这部分说的有点多, 但其实非常简单, 就是"我看了`linus`开发`linux`时的情况". 不过阅读的时候, 也没想太多, 这些总结, 也就是写的时候分析了一下, 感觉还是很清晰的. 

- 有了想写操作系统的想法.
    - 为什么呢? 
        - 之前说的`neovim`的配置, 其中就有, 自己简单复刻了`nvim-tree`, 知道了是什么, 明白了接口, 之后写相关脚本轻松了很多, 查阅相关文档, 阅读起来也很明确了. 突破进阶的点, 就是自己尝试复刻`nvim-tree`后发现, 也就那样, 朴实无华, 并没有多么困难. 我想, 编写操作系统的话, 表面上看起来, 非常庞大, 但是, 该操作系统仅面向个人, 用不到很多保护性代码, 实现关键细节就行, 所以, 也没有想象中的那么复杂(难度肯定是有的).
        - 另外, 阅读的`linux`内核的书中, 说了, `linux 0.12`版本内核代码, 才两万行, 并不是很多. 
        - 复刻/重写, 才能有自己更深入的理解. 
        - 兴趣驱动. 此时产生了浓厚的兴趣. 我曾深入地学习过嵌入式, 对于`stm32`的运行, 有了基本了解, 但是, 对于`os`, 底层细节驱动并不清晰, 所以迫切地想知道其底层驱动实现原理.
        - 问题驱动. 对计算机硬件跟软件端交互, 存在问题. 怎么实现的呢? 
    - 有了想法之后, 便要具体实现了. 上面说的五条, 其中兴趣驱动, 问题驱动, 包含了, 那么, 还缺少前三条(我不说细节了, 就用第几条表示了, 具体可以回看上面). 那么, 怎么弄呢?
        - 关于代码的编写, 运行, 编译这方面, 我没太细致地考虑过, 当时或许只是单纯地认为, 编译一下就可以. 所以主要想着弄可视化反馈的东西.
        - 可视化反馈的东西, 最简单的其实就是再搞一台电脑. 但是没有这么多钱, 肯定不合适. 后面, 我觉得`stm32`是不是也可以运行`os`呢, 于是便`ai`了解了一下, 确实能运行`os`, 但是是实时`os`, 跟计算机的`os`还是不太一样. 后面, 我又从`ai`那里了解到了工控主机. 所以便从淘宝/京东/闲鱼各种搜工控主机. 有便宜的, 也有贵的. 不过现在又存在一个问题, 怎么将我的`os`代码放入测试运行呢? 是否可以反复运行测试呢? 商家只提供机器, 不提供教程, 没办法, 只能问`ai`. 从`ai`那里了解到, 似乎不可以. 现实的`os`编写测试运行, 都是在虚拟机上进行测试, 然后再装到实体机上. 于是, 我又从`ai`那里了解到了虚拟机`qemu`, 很不错的测试`os`的软件.
            - 另. 上面问了很多次`ai`, 但是`ai`并没有一次性给出我想要的结果. 为什么呢? 肯定是我询问方式和侧重不同. 一开始, 我的目标就是准备一台实体机(完全仿照`linus`), 所以, 询问层面, 也是更倾向于实体机, 而不是虚拟机. 后面了解到实体机编写`os`并不现实, 转而才打起了虚拟机的注意. 所以说, 靠`ai`获取有用的信息, 并不是一次性就能获取的, 你的想法, 见识, 决定着你使用`ai`的高度.
        - 可视化的东西搞到手了, 编译环境上犯了难.
            - 这部分, 我是一直问着`ai`, `ai`也能给出方案. 我的目的也很简单, 就是在`qemu`中, 显示好我编写的`hello world`即可(之前觉得, 第一次学习某种语言的时候, 输出`hello world`, 是很可笑的, 因为太简单了. ), 可是却一直实现不了. `ai`给的方案, 总是我不熟悉的, 所以, 只能盲目地选择相信. 若要问为何不系统地学习一下, 可是, 我的目的很简单, 就是输出`hello world`啊, 系统性地学习什么呢? 资料从哪来呢? 只能从`ai`获取啊. 
            - 我试了`windows`端, 发现总有问题, 又试了`linux`端(上周的事了, 因为上周也是操作系统实验时弄的, 现在我也刚好上着操作系统实验, 哈哈), 反复编译测试了许久, 最终的结果还是不行. 
            - `hello world`都输出不了, 那还写什么`os`, 哈哈. 
        - 所以, 放弃了`ai`, 转而去`b`站, `csdn`等平台, 搜寻答案. 最终还是找到了. 它的内容完全符合我的期望, 编写`os`, `qemu`虚拟机端编写, 整体`6000`行左右. 怎么样, 熟悉吧, 上面的第三条. 虽然一二条没搞好, 但是搞定了第三条, 相当于把一二条都搞定了.
            - 为什么这里说一二条都搞定了呢? 因为符合期望的那个视频, 是个卖课的, `700`多吧(`700`多好像不止写`os`这个, 还有其它的项目). 我肯定是不会买的, 所以去闲鱼搜, 还是找到有人在卖, 我买了, 花了`0.1`元, 几乎包含他的所有项目, 十分齐全(这样做对吗?).
        - 由此, 上面的五条集齐了(虽然跟着教程, 环境方面, 可视化方面的配置, 还是很难搞, 但是比起盲目地问`ai`, 已经好很多了)

- 剩下的时间, 就是跟着教程学习编写`os`喽.
    - 他的整体项目中, 内置了个小项目, `200`行代码, 编写一个小型的`os`, 我一直看着这个, 先宏观了解一下.
        - 因为有嵌入式的学习经验, 所以我十分清楚, 单纯地看视频, 写代码, 肯定是不行的. 重要的是有思考过程.
        - 这个阶段, 我会看视频, 虽然看不懂, 但是会把代码写下来, 然后运行测试一下, 接着问`ai`, 增强自己的理解. 
        - 之后, 会像现在一样, 写个思考文档. 把自己所有的心理表征写下来, 让自己有一个清晰的认识. 
    - 由于我个人不会仅限于他教程中的内容, 总想尝试`diy`编写一些代码, 所以问的会十分深入, 直至完全明白, 才进行下面的内容. 因为我知道, 只为了赶进度, 为了看完视频而学习, 是没有用的, 深刻理解之后, 再往下进行, 才最有帮助.
    - 这个时候呢, 学习了一些汇编代码, 并且计算机底层的代码编译方式, 也有了一定的了解, 像汇编+`C`语言混合编译, 等等. 另外, 也写了写`makefile`脚本, 有了一定的认识. 
    - 现在着重说说上面的第二条, 可视化方面吧. 这里的可视化, 其实就是`debug`层面的, 并不是说虚拟机端运行, 输出`hello world`这些, 而是通过`gdb`调试, 查看虚拟机内部, 各个寄存器存储的内容. 每执行一行代码, 目标寄存器的内容是否能如期地变化(到目前为止, 一切皆符合我的预期). 虽然代码是别人的, 但是可视化都是我自己搞出来的. 
        - 教程是通过`vscode`编写的, 我虽然有`vscode`, 但是我不愿意用, 我还是喜欢用终端. 所以需要添加许多额外的配置. 以前`gdb`调试, 没用过, 我知道`python`有类似的, 之前学习过, 但是`C`语言的, 确实是没用过. 所以, 专门学习了一下, 并且写好了对应的脚本, 可以完美地运行, 可视化方面也打破了壁垒(当然, 脚本不是一次性写好的, 是按照需求, 一点一点补充的.)
    - 至于为什么要搞得这么麻烦, 是因为, 后续我希望用`C++`开发一个软件(有了具体的设想), 所以环境等方面的问题都需要专门解决的. 肯定不是等后续开发的时候, 专门去解决, 不如将这些可能用到的东西, 提前搞一搞, 位后续做做准备, 多了解一下, 也是很不错的.

- 由于`os`弄得太过顺利了, 所以昨天的时候吧, 又打算着手弄另一个东西了. `C`语言重写一下数据结构, 一直弄到了今天. 这部分才是困扰我的所在, 而并不是`os`, 所以, 这里只是简单地描述一下, 后面详细地说说.
    - `C`语言重写数据结构, 也非常简单, 但是我不想仅限于此. 我想的是, `C`语言底层封装, 编译后能被`python java lua`等其他语言调用.
    - 这个想法, 其实并不是昨天才想到的, 而是很早就有疑问了. 比如`C`端跟`python`端, 语言是如何交互的? 以前, 可能会认为, `.c`文件, `.py`文件, 相互导入即可, 可能需要一些中间库的搭配. 可是`python`太慢了, 这么做, 肯定是有问题的. 那么是怎么弄的呢? 
        - 这个疑问一直有, 但其实早就解决了, 怎么解决的呢, 问的`ai`.
        - 我是这么问它的, `python`的`numpy`, 是一个高性能的数学库, 底层是`C`编写的, 可是, `python`端怎么调用的呢? `pytorch`也是同理, 等等等等.
        - 但是似乎也用`lua`配置`neovim`这段时间, 产生过以为, 比如, 用`C`编写的一个主题库, 通过`lua`编写相关接口后, 就可以被`neovim`调用, 那么, 这个接口是如何协调两个语言的呢?
        - `ai`告诉我一个关键性文件, `.dll`文件, 动态编译库. `.dll`文件, 很早就从手机端见过, 电脑端也见过, 但具体是什么, 也不清楚. 好了, 现在清楚了, 哈哈.
    - 所以说, 我之前只是知道这么弄可行, 但具体如何操作, 确实没弄过, 所以, 昨天打算弄弄, 因为感觉也不算困难.
    - 其它具体的, 下面再说吧. 

整体上来看, 这`10`天差不多就干了这些事吧. 复杂吗?(复杂)困难吗?(困难)学到真东西了吗?(学到了)所以说, 仅仅会用某种语言, 会用某种语言的库, 完全是不够的, 还需要会准备环境, 搭建好能够运行的环境, 似乎比单纯地写代码还要重要. 刚开始学编程的时候, 就知道, `python`比`c/c++`简单. 可是所谓的简单是指哪方面的呢? 以前可能觉得, 指的是语法层面. 但是其实语法层面是最不重要的, 因为`python`也有独属于自己的特性, 学起来也不容易. 目前来看, 我觉得, 这里的简单, 应该指的是环境配置上的简单, 而不是语言/写代码层面上的简单(当然, 如果后续我能熟练创建各种`C/C++`环境的配置(包括用户端编写代码, 还有底层`os`/汇编相关的代码), 可能也会觉得简单, 哈哈).  

### 原因

昨天的时候, 也只是觉得, 简单弄一下就好, 同样, 还是从`C`端写个函数, 输出`hello world`, 然后在`python`端调用这个函数, 输出`hello world`. 最后也没有实现, 哈哈. 所以说, 输出`hello world`这么困难吗? 我是先写好了整体的框架, 并且写了对应的`CMakeLists.txt`文件. 当然, 也是跟`ai`学的. 并不需要一次性记住, 我只需要知道, 我的目的是导包, 能跨文件访问数据, 并且能实现`Clang`代码自动补全即可. 这部分很简单, 搞得也很快. 之后, 又写了相关的脚本文件, 方便编译运行. `Makefile`文件, 可以很容易地写编译脚本, 但是`CMakeLists.txt`似乎是不好实现. `windows`端又不支持`.sh`脚本编写, 所以我只能编写`.ps1`的`powershell`脚本文件. 不过好在之前有经验, 实现起来也不困难.  
不过, 当时也是遇到了困难. 问题是, `CMake`编译参数, 不支持`powershell`的参数变量. 由于当时写了挺多代码, 一开始没问题, 后面集成封装了一下, 发现总是报错, 问题又不知道在哪. 问`ai`, 也解决不了. 此时, 我就又重新写一个脚本, 逐步进行测试, 最终找到问题所在, 也就是上面说的原因. 
整体上, 没太大问题了, 能编译了. 接下来, 就需要`python`端的编译即可. 我了解了一下, 发现`pybind11`, 用作`C++`的移植, 是很不错的, 所以结合`ai`, 写出了相关代码, 并成功编译成`.psd`文件. 于是, 弄了个python文件, 并且导入, 发现`pyright`并没有报错, 说明存在对应的模块, 并且`pyright`能够识别, 可是后来发现, 运行就报错.  
为什么呢? 整体上来看, 都没问题啊, `C`端编译正常, `pyright`也没有报错, 能正确识别这个函数, 怎么运行就出问题呢? 没办法, 只能问`ai`. 了解到, 除了`.psd`文件, 可能会有`.dll`相关的依附动态库. 我找了一下, 发现确实有一起, 于是抱着期望, 将这个`.dll`文件放到同目录下运行, 还是有问题. 此时我觉得, 是不是将`.dll`相关内容, 集成到`.psd`文件中, 就可以啊? 于是将`.dll`文件又集成了一下, 发现还是无法导入.问了问`ai`, 还是不行. 然后呢, 我就看视频了解, 发现`macos`端, 操作跟我一样啊, 怎么就能正常导入呢? 我`windows`端怎么不行呢? 又去`pybind11`官网看了看, 也没看出个所以然来, 示例代码跟`ai`给我的差不多, 理论上应该能导入啊?  
昨天晚上弄到`11:40`多吧, 不甘心地睡觉了. 昨天晚上也一直在弄这个, 就是没法成功导入. 可是睡觉之前, 我看了一个视频, 说, 用`visual studio2022`编译就行, 在`pybind11`官网上也看到了, 用`visual studio`编译, 但是当时太过混乱, 没多想, 也不愿意想, 于是去睡觉了. 第二天呢, 也就是今天, 上午一上午的课. 课上无聊, 我又复盘昨天的失利. 想了想, 应该是编译的问题. 我是用的`gcc/g++`编译器, 可能就是因为编译的问题, 导致不可行. 于是, 便问了问`ai`, `windows`端, 编译成`.psd`相关文件的话, 是不是必须要用`MSVC`(也就是`visual studio`)编译器, 它说是的, 其它编译器(`gcc/g++`等), 会存在问题.  
我直接震惊了. 昨天的时候怎么不说限制编译器呢, 我问了才说...幸好看视频, 看文档了解了一下, 要不然, 一直被这个问题困扰. 所以, 今天上午的时候, 虽然两节课, 我已经大体构建了思路, 回去先下一个`MSVC`等工具, 然后再重新编译测试一下. 也考虑了`C`端的整体架构是有问题的, 我是在`core`核心数据结构代码同目录下, 创建了一个`bindings`文件, 内部又有`python java lua`等代码对应的编译包. 这是有问题的. 数据结构部分代码, 应该单独出来, 然后, 我想绑定到`python`端, 创建`python`相关项目目录, 将数据结构的项目整体放到`python`项目中来, 然后写对应的`.txt`编译文件, 这样才对. 等写`java`的时候, 也是同样的道理.  否则, 按照我之前的思想, 代码杂糅太厉害了, 而且需要一直修改`.txt`文件, 这是非常忌讳的.  
回去之后, 先下载相关配套工具, 可是有很多东西, 比如需要学习`cl`终端的使用方式. 另外, 还需要重新修改数据结构端的代码, 以及`CMakeLists.txt`代码. 由于`CMakeLists.txt`的语法还不是很熟悉, 所以还是比较头疼的(也不是很头痛的那种, 主要是存在多种编译情况, 每种编译情况代码还不一样, 总是害怕忘记). 对了, 还有`powershell`的脚本代码, 也是写好了, 都需要重新修改了. 此时, 差不多到了`1:40`, 觉得太过混乱了, 有太多的东西要重新弄了. 虽然有了应对方案, 但还是想上床休息休息. 最后, 在床上睡了一个半小时, 又看了一个小时的手机, 并且思考了三十分钟(其实没这么多), 想明白, 准备下床搞搞(此时到了`4:40`).  
最后呢, 想了想, 还是写写这个文档记录一下吧, 于是写到了现在`22:12`(当然, 不是一直写, 中间去吃了顿饭, 并且晚上还是操作系统实验课).  

### 反思

今天写这个的时候, 觉得, 用来当做数据库的`ai`使用分析还是不错的, 所以里面也加入了使用`ai`的一些点, 虽然不是针对数据库层面的, 但是宏观`ai`使用的描述, 还是比较详细的(比如说, 什么情形下, 使用`ai`, 虽然没有贴详细问答情况, 但知道什么情况下回去问`ai`, 我觉得也是足够的). 另外, 这写内容全是自己手写, 没有任何`ai`痕迹的真实报告, 而且是真情流露, 参考价值极大(至少我是这样认为的) 下面再说说具体的反思吧. 会结合多方面的, 而不是仅限于某点.  
- 我觉得, 我是来拓展视野的. 如果我知道的足够的多, 范围面很广的话, 那么, 我只需要详细地问一下`ai`某项领域的实现细节, 问题几乎就能解决. 但是, 如果我是纯小白, 不知道从`0`怎么弄的话, 很难一次性(注意, 这里是一次性)向`ai`问出解决答案来, 需要能比较, 分析, 判别的能力. 
- 在`os`层面, `ai`并没有直接解决我的问题, 反而是第三条, 解决了我的问题. 一开始的话, `ai`确实浪费了些时间, 但是我也了解了些东西(比如工控主机等). 但是, 跟随他人学习`os`的时候, 深入理解方面, 全是借助`ai`. 
- `C`代码移植`python`层面, `ai`最后也没有解决我的问题. 不过, 它其实解决了我大部分的问题(代码没有问题, 相关库的选择, 给我了很多的参考), 最终只是差在了编译器不对. 最后从视频, 文档中了解到, 需要`MSVC`编译器编译才行.  
- 昨天晚上一直导入不进去, 心情十分低落, 但是今天上午想明白后, 又有了动力. 不过中午下载相关依赖后, 又被许多问题压在身上, 选择了先去休息休息. 最后又写了这个总结.
- 最后, 这里再分析一下`ai`的使用吧. 
    - 对于理解层面的东西, 毫无疑问, `ai`是最有用的, 比课本有用, 能增强心理表征. 有了足够多的理解后, 再去看课本, 很有帮助(比如, 单纯看`linux`内核的书的时候, 只能理解一小部分. 通过`ai`, 有了一定的理解, 并结合自己写了一些`os`后, 再去看书, 能看懂很多了. 但是, 没有前面的前提, 单纯地看书, 几乎毫无用处.).
    - 语言语法的学习, 命令行的使用, 软件快捷键等的学习 `ai`也是最有用的. 这些东西比较固定化, 而且能迅速得到反馈, 对就是对, 错就是错. 绝大部分情况下, `ai`给的都是对的.
    - 自己认知之外, 完全不了解的东西, 慎重选择`ai`, 它大概率会给出解决方案, 一定情况下, 可能是对的, 但是如果是错的, 可能会陷入循环之中, 一直错下去. 此时视频, 文档是最好的解决方案. 所以, 这个时候, 使用`ai`, 不要问它解决方案, 而是将具体的问题问它, 看它如何解决. 对于给出的方案, 再问它是什么, 千万不要直接`copy`代码测试, 先知道它说的是什么东西, 干什么用的, 看看逻辑是否正确, 再向它要到参考网址, 仔细看看对应文档. 这样比重复地问`ai`强很多.
    - 当然, 最好能找到教学视频, 这样就会符合第三条, 比较类似上面`os`时的情况. 
    - 所以, 感觉上复杂的项目/问题, `ai`不是首选, 文档, 视频, 第三条, 是最优选择. 理解层面, 固定语法层面, `ai`是首选. 
> 今天已经`22:47`了, 就不弄代码移植的那个了, 明天再弄吧. 关于那个东西, 只能依赖`ai`. 先弄个最简单的`C`和`python`代码, 然后编译, 看看能否导入, 能导入的话, 再去写写数据结构, 并且写写`CMakeLists.txt`, 看看编译链是否有问题. 假如一开始导入失败的话, 我会怎么办呢? 查找文档, 了解一下实现细节. 不过, 理论上一定可行, 如果不可行的话, 那我也确实是没有办法了. 

### 01反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.6 10:37  

我服了, 今天早上起来, 感觉搞了有`15 min`吗, 就解决了...我还以为, 仍要搞上半天呢, 原来不用...无语. 如果是昨天混乱的情形, 还不知道搞多久呢. 下面就记录一下, 我如何问的`gpt`吧.
- 第一条
我现在想用pybind11, 编译C++, 然后在python端调用.  
注意, 我用的是MSVC编译器(Tools 命令行工具), 没有visal stdio,  
请告诉我详细地pybind11 绑定步骤.  
最简单的就行.  
不要有其它额外操作, 谢谢  
- 第二条
{  
    "venv": "AI",  
    "venvPath":"E:/Anaconda3/envs"  
}  
这是我的虚拟环境目录  
E:\Anaconda3\envs\AI\libs 这是libs  
E:\Anaconda3\envs\AI\include  
这是include  

我的python是3.11版本的  

"F:\MSVC\Tools\Common7\Tools\VsDevCmd.bat" -arch=x64  
这是我的MSVC路径  

F:\0github\Learning-Computers\programming-language\python  
这是项目路径  

请集合上面路径, 详细说说  
- 第三条
F:\0github\Learning-Computers\programming-language\python\pybind11  
这是我的pybind11路径  

---
问了第一条后, 我发现它不知道具体路径, 我就将对应路径给它, 然后问了第二条. 之后我发现, 它假设我`pip`安装的`pybind11`, 但其实我是自己下载的, 这样它就不知道我的路径, 所以又问了第三条, 然后, 按照它的代码和命令行, 成功实现了我想要的效果. `15 min`搞定.  
当然, 这里使用`ai`, 是为了了解/熟悉一下流程. 因为之前失利过, 所以这次只需要最最最简单的方式测试即可, 明白基本的操作流程后, 便可以自定义`diy`了. `easy`, 散会!

---
算了, 再来总结一下吧.  
- `ai`怎么样, 还是要看用的人. 假如基本流程我很熟悉, 就是代码/命令行有些记不住, 那么, 我可以把很多关键信息, 有用信息提供给它, 只是需要它给我的代码/命令行即可.
- 可是, 如果我是真的纯小白, 不熟悉流程, 没有基本思想, 怎么能向`ai`问出好的问题呢? 相反, 如果在我很懂的基础上, 我能问出个花来. 不过, 我都很懂了, 肯定也不会选择问`ai`.
- 我的需求, 其实非常简单, `python`调用`C/C++`. 如果直接去问, 它会给出很多选项, 选哪一个呢? 我的要求是快, 难点, 复杂点也无所谓. 这时, 选出来了目标库(`pybind11`), 再去问它如何实现. 可是, 用了`n`种方法, 流程层面, 都没问题, 可就是调用阶段, 总会错误. 什么问题呢? 不知道. 继续问`ai`, 也问不出来了. 于是看视频, 查资料, 发现是编译器的问题. 于是, 问了关键性问题, `python`导入动态库, 编译器是不是有限制? 果真, 我知道了, 只能用`MSVC`编译器. 我一开始怎么不问编译器是否有要求呢? 因为我压根不知道这个点, 默认`gcc/g++`就可行, 但实际上呢, 并不行. 
- 这个问题, 很早就思考问过`ai`, 我就知道`.dll`动态库, 可以灵活导入. 脑海里想的是, 只要成功编译成`.dll`动态库就行了, 其它的就很轻松了. 可是真的轻松吗? 简单倒是挺简单的, 但是坑却都踩了一遍.
- 其它的总结, 之前也都说过了, 我今天也就是按着流程走了一遍. 不多说什么.额, 结束.

### 再反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.08 17:59  

为什么是再反馈呢? 这个文档主要是记录难受时/毫无斗志时的状况与解决方案. 而写这个时, 并没有出现什么消极的心理状况(可能有, 哈哈), 主题也与上述基本一致, 所以是再反馈. 罗列一下吧, 并且将问题说出来.

- 上面的内容, 有关键的五条, 列举如下.
    - 良好的编写代码/运行代码的环境.
    - 良好的可视化的反馈.
    - 可参考的开源代码/书籍.
    - 兴趣驱动.
    - 问题驱动.
- 最终解决我`os`问题的是第三条, 所以默认为第三条很重要. 第三条确实重要, 但是让我搞不清主次了. 
    - 问题其实还是在`cmake`上. 上面说了这么多, `cmake`对于`C/C++`开发, 确实是很重要. 所以, 后面我就又打算专门去学习`cmake`去. 
    - 此时, 跳过了`ai`, 直接先找书, 又去咸鱼上找项目. 果然, 找到一个.
    - 可是一打开发现, 全是视频, 最后有些`cmake`的代码. 
    - 标题起的很好, 内容也很丰富, 什么都有, 学会了一定很好. 可是, 真的适合我吗?
        - `cmake`困住我的点是什么呢? 
            - `target`, `library`, 等等, 表意不清.
            - 变量, 字符串, 路径名, 分不清.
            - 逻辑, 层次引用关系, 分不清
        - `cmake`跟传统的高级语言还不同, 不像其它语言那样容易区分.
        - 虽然跟着`ai`, 能写出来, 但是, 还是会非常混乱的, 虽然能正常编译, 可是看到那些函数名, 不知道作用, 比较茫然.
        - 视频的问题是什么? 
            - 并没有直接解决我的困惑, 前面简单的时候好些, 后面复杂的时候, 还是会混乱(可能因为没认真看的原因, 但确实讲的不好).
            - 三端一同讲解(`win`, `linus`, `macos`), 不是说不好, 但是我是不愿意看的
            - 给的项目代码, 不是完全版, 跟视频中讲的无法对比上(可能有三端的代码, 但是很明显, 我拿的不是`win`端的代码. 也怪不了什么, 毕竟闲鱼`0.01`薅的)
        - 后来, 我才明白, 我还是不适合看视频学习. 被上面的`os`, 蒙住了双眼. 
            - 仔细回想一下, 我看视频学习, 只有嵌入式, `os`, 这种比较偏向底层的(应付期末考试的视频学习不算, 那种是被动学习, 这里说的是主动学习). 当然, 还有数学的一些深入理解的视频, 有疑惑的时候, 才会搜搜看看. 
            - 像这种`cmake`, 看视频学, 根本不可能的, 几十个小时呢. 
            - 虽然说, 学会了, 肯定很美好, 但是, 对我自己来说, 看完一遍视频, 根本不可能懂的. 所以不适合我.
        - 想了想, `cmake`可能还是缺少可视化, 当时不知道直接输出测试的. 
- 经历了上面的之后, 我打算, 还是要自己主动创造, 动手从零慢慢写. 理解层面的东西, 还是要靠`ai`的, 从视频中对我而言, 肯定无法获取到什么的. 
    - 我主要是想自己写. 但是呢, 终端的`cmake`没有补全, 那些函数什么的, 根本记不住, 只能对着写.
    - 能带着自己的思想写, 想干什么就干什么, 不受限于其它, 这是我的目的. 
    - 最后呢, 也确实是实现了. `cmake`语言形成了自己的一套规范, 能够很好地区分出来什么是什么, 而不仅是一串看起来都相同的东西. (这里说起来容易, 但是做的时候, 也很不容易. 不过好在都区分了)
- `cmake`弄好后, 我又想着将`C++`代码弄到`python`中去了. 不过又走了远路.
    - 之前弄的, 就仅仅在`bind.cpp`中进行绑定. 我期望的是能灵活绑定, 灵活导包, 而不是十分受限地进行操作.
    - 这里涉及到很多难点. 当时其实都不知道, 但因为走了很多的远路, 所以也了解了很多, 基本的原理也都明确了.
    - 在此之上呢, 我就打算尝试复杂导包, 并且写好`cmakelists`. 但是呢, 问题还是发生了, 总是有错误. 改来改去, 错误依旧在. 最后实在没办在了, 只好上床休息一会. 等着从床上下来的时候, 已经有灵感了, 就是跨度太大, 结合基本的, 一步一步慢慢添加就好, 不用一口吃成个胖子. 
    - 上面说了, `cmake`有很多函数, 背过不可能的, 所以, 我还是对比着写的. 最后写完的时候, 也终于发现了一个极有可能的错误点, 就是在添加库的时候, 应该先添加`core`, 后添加`pybind11`, 可是我这两个写反了.
    - 测试了一下, 果然是.
- 上面说了很多, 但只是大体描述了一下. 真正修改/`debug`/理解/一直编译不通过时的心情, 很难描述出来. 最后呢, 是能编译过, 但是却发现`python`端导包, 一直有问题. 不过最后问题实际上, 也很简单, 这又说明了什么呢?
> `cmake`, 对我来说, 肯定是非常重要的, 专门学习一下, 是必须的. 虽然走了很多远路, 但是对于理解层面, 能够起到很多的帮助. 现在了, 能够精细化地自己编写`cmake`了, 而不受限于`ai`. 虽然, 精细度还不够高, 但目前能解决我大部分的困惑足矣. 等后续, 需要进一步深入`cmake`的话, 再去了解即可. 其实就跟`vim`一样, 刚开始的时候, `vim`操作不熟练, 脚本自己也不会配置, 困难点多了去了. 但是练习两个月后, 再此基础上, 重新配置的话, 手拿把掐. `cmake`也是刚开始弄, 一上来就想全学会? 根本不可能的.

### 再再反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.09 11:51

昨天凌晨一点多, 又买了好几本书, 两本`xml`相关的, 一本计算机图形学, 一本`cmake`相关的, 一本`vulkan`相关的(只有这个是一手的, 上面其他的是二手的, 比较便宜). 感觉从大二到大三以来, 所学的一切, 都是在为开发这个软件而准备着, 有意无意中, 很多东西都是相通的. 其它的先不说, 就这几天的`cmake`, 就很有必要. 本来打算后续要`c++`开发, `cmake`必不可少, 所以了解一下. 后续用`pybind11`, 需要用到`cmake`, 底层`os`, 也跟`cmake`有关. 直到今天看了`vulkan`的电子书, 发现里面也是用`cmake`构建的. 一开始学`cmake`的时候, 并没有考虑这么多, 只觉得以后可能会用到, 但没想到, 确实很常用. 另外, 还有`xml`. 之前看面向对象设计的书中, 有提到过`java`里面的相关`xml`的包, 但是当时不知道`xml`是什么. 后续, 又疑惑, 为什么有的软件能自定义后缀名(之前弄`pr`的时候, 会有`pr`相关的工程文件, `adobe`其它的文件都会有专有的后缀名. `keil5`也是), 通过`vim`打开, 发现是纯文本, 复制给`ai`, 了解了自定义后缀名的原理, 也知道了`xml`是什么. 嗯, 那我也就知道了, `xml`也是需要学的. 昨天上`web`的时候, 又听到老师说, 数据库跟高级语言间, 可以通过`xml`交互, 那确实, `xml`需要专门了解一下了, 于是又买了书, 打算看看. 等等等等还有很多, 也就不细说了.  
昨天发现, 通过`C`写的代码, 给`Python`调用, 必须通过`C++`来一层中间调度(`pybind11`)绑定. 也没当回事, 打算就是专门地写一层`C++`就好, 其它的也不用过多地考虑. 今天上午写的时候, 发现, 写的这一层中间层, 目前似乎专门为`python`准备的. 可是这一层, 完全可以剖离出来. 什么意思呢? 就是底层`C`写好, 中间层`C++`封装调用. 这样来看, 底层其实就只有`C`, `C++`, `python`只能通过`C++`绑定, 那么我只调用`C++`即可. 其它语言呢, 可以调用`C`的话, 就直接调用`C`, 能调用`C++`, 就直接调用`C++`即可, 其它的也不用管了. 模块化, 需要足够地清晰.  
刚才又想了想, 那我为什么不直接编译成动态库, 这样每次只需要携带一个动态库就行, `python`端只需要写一个绑定代码, 然后链接这个动态库即可. 这其实就涉及到`cmake`的高级用法了. 可以灵活性地编译, 而不受外界影响. 现在我知道以前的那个视频里有相关的描述, 但是也不太想看, 因为肯定说的很复杂, 我想了解的那个点, 很难直接找到. 所以, 还是结合`ai`, 了解一下. 另外, 也不要在当前的复杂环境中交互, 完全独立出去, 剖析成最简单的部分即可.  
一直这么重复地弄, 有意义吗? 肯定有. 表面上是在弄`python`如何调用`C/C++`, 实际上是在学习`cmake`. 搞明白上面说的那个, 有更进一步了. 这样后续可以灵活编译, 更加清晰明朗. 固然, 我也可以一次性写完, 全部编译成静态文件, 但感觉实际中肯定不是这么干的. 加强灵活性是必然的.  

### 再再再反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.10 15:12  

把`cmake`几乎搞明白了. 当然, 还有很多东西, 比如说, 动态链没怎么弄, 但觉得静态链搞明白了, 动态的就差不多了. 另外还有`.cmake`自定义配置相关的东西, 目前来看, 没太有必要, 自动生成就可以了. 总之, 目前这个状态就比较满意.  
昨天跟一个算法很好的人聊了聊天, 想向他取取经, 但结果还是比较让我失望的, 这里细节就不说了. 我自己呢, 很愿意学习底层的东西, 这样的话, 写代码能够精确控制. 所以整体理念, 就是向`ai`学习, 学的差不多后, 可以自己主动编写, 而不是仍旧依靠`ai`. 之前看了个斯诺克视频, 里面有句形容火箭的话, 是"母球所到之处, 即是心中所想". 这很符合我学习编程的思想, 每一行代码, 都能达到自己心目中想要的效果, 每一个错误, 都在我的预期范围内. 但是`ai`写的代码, 很难控制. 如果想要添加些东西, 或者删除些东西, 几乎无法添加. 当然, 我们可以仍旧扔给`ai`, 让它修改一下. 但我觉得, 这是那些不会编程的人弄的, 身为计算机的学习者, 应该能够达到精细化控制的效果, 而不是被`ai`掌控. 为什么渲染引擎我选择学习`vulkan`, 而不是`opengl`呢? 就是`vulkan`能够精细化地控制. 在我看来, 并不会因为难而选择放弃, 而是因为能够精确控制, 我才选择学习. 当然, 网上他们说`vulkan`怎么怎么难学, 我觉得, 还是缺少其它知识的补充. 在我具备很多额外等东西后(尤其是底层`os`运作原理), 其实也就没有那么困难了. 
回过头来再看看, `cmake`是否难学呢? 我觉得困难点还是变量命名不清晰, 代码多了容易乱. 所以, 我都会选在用`${}`变量显式地标注出来, 能够让我很容易地看明白什么意思. 从专门想学`cmake`, 到现在, 在实践中去理解, 用了差不多三天的时间吧. 之前买的那个视频, 二三十个小时, 专门学的话, 肯定不止三天. 我的目的是快速掌握, 快速理解, 不是细嚼慢咽地学习, 太拖拉了.  
以前很害怕学习新的东西, 总想安于现状, 所以很多东西都会选择通过`ai`快速解决. `cmake`或许就是这样的. `ai`虽然能快速给我大差不差的`cmake`代码, 但是, 我自己几乎无法修改, 想要修改只能再喂给`ai`, 也就是我上面说的. 不过专门学习一下, 自己抽象模拟项目的话, 也就`3`天的时间, 就能掌握大部分内容. 嵌入式的相关东西也是, 我就用了一个月的时间, 明白了很多很多, 自己也能写代码, 主动控制, 这是我一开始没有想到的事(当然, 这期间我付出了很多, 其实也都是向`ai`学习的, 底层原理知识, 靠`ai`理解的. 后面我自己写了个`c++`库, 又明白了`c++`在裸机嵌入式的应用.虽然设计的不太好, 但是也确实锻炼了代码能力). 所以说, 学习新东西, 并没有多么困难, 享受学习的这个过程. 从不理解->理解, 真的很有意思, 当然, 有意思的是理解时的过程, 并不是理解后的应用. 在理解很多东西的前提下呢, 学习新的东西的速度会更快.  

---

&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.10 21:08  

这次是想写点数据结构与算法的东西. 之前数据结构与算法, 确实没怎么好好学, 这几天打算重写一下数据结构, 上面做的一切, 其实都是在准备着(项目的抽象模拟, `C`端写的数据结构更具备通用性). 准备完之后呢, 还是要重新回归写数据结构的.  
上面也说了, 我学习编程, 是为了能精细化地控制, 达到"母球所到之处, 即是心中所想"的境界. 数据结构与算法也是如此. 那么如何做到呢?  
一开始尝试写了写`SqList`, 发现还是按照书上的内容写的, 缺乏个人思考, 说白了, 没有任何效果. 后来呢, 我就设想, 假如, 我将我的`SqList`移植到`python`端, 会存在什么效果? 课本上, 只有线性表的初始化, 销毁, 清空, 插入, 删除, 遍历这些内容. 其中, 插入的话, 只是一个一个的插入. 如果`python`端, 我传入一个列表对象, 单单就上面几种方法, 肯定是不行的. 如果在`python`端循环插入, 速度反而更慢(每插入一次, 就需要调用一次, 效率更差). 此时我知道, 可以添加一个方法, 能够以数组(指针)的形式存储.  
后续在具体实现`ListInsert_Sq`的时候, 还是缺少常规性的思考. 这些东西呢, 在暑假的时候分析过, 但是到现在呢, 也都忘了. 什么原因呢? 缺乏系统性的学习. 当时可能只是为了解释而去解释, 没有太大意义, 时间一长, 理解可能就变了. 此时我有一些问题, 比如:课本上`position`从`1`开始的, 而我更习惯从`0`开始, `if`语句判断, 存在两种可能(< > 或者<= >=), 选择哪一种呢? 同理, `for`循环也是, 这种多向的选择, 容易造成我理解性的误差(什么时候带等号, 什么时候不带呢? 如果用哪种都行的话, 是不是我固定成一种就可以呢?). 带着这种困惑, 我问了`ai`. `ai`直接完美地解决了我的困惑. 下面是我添加的注释(英文的, 因为写中文, 编译时可能会有警告, 为了避免警告, 就写了英文的)  
~~~C
/* 
    is position legal?
    realloc?
    position start at 0 or 1? if flag == 0 -> start at 0 else start at 1
    updata capacity?

    understand operation space
        for array, we use [0, n), which is 0-based.
        so, to solve this problem, the position parameter also use 0-based.
        the position parameter's operation space is [0, L->size]( L->base is [0, L->size) )
        so, the illegal operation space for position parameter is (0, L->size) . easily.
        for k, its operation space is [0, L->size) ( [0, L->size - 1] to fit position parameter' space operation( [0, L->size] ) )
        so, if k == position, we'll insert. if k > position, we'll not insert, its illegal.
        based this, we know the for loop condition , which is (k = L->size - 1; k >= position; k--)
    the for loop condition we've got, is based on the position operation space and the k(L->base) operation space.
*/
~~~
这样呢, 我就有了自己的一种思考方式. 在遇到类似问题时, 可以去思考操作空间, 基于此, 来判断对应条件, 这样也就避免了使用`ai`, 或者是直接去抄课本.  有了自己的思考, 是我能做精细化编程的前提. 算法, 有灵活性的算法, 有思想的算法, 肯定是带着自己思考去解决的, 而不是靠`ai`. `ai`只是提供给我各种思考方式, 让我去理解, 并产生自己的理解, 从而能够独立地思考.  

## 2025/12/22
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-22 18:07:43  
注意, 下面的内容呢, 并不是一口气写下来的, 所以读起来会有断断续续的感觉, 缺少连贯性. 可能在说着`A`, 下面突然越到了`B`. 不要在意, 也不是逻辑问题. 

---

- 前两天吧, 又被面向对象设计与分析搞得比较难受. 设计类问题, 跟编程学习有很大的不同, 所以说上面的内容很难移植到设计上面来. 我自己喜欢底层高度抽象化设计, 但是呢, 缺少良好的建模思路. 写倒是能写出来, 但是总会多方面分析是否合理, 或者结合`ai`, 看看有没有更好的解决方案.  
- 面向对象设计类的书也有, 但这些东西肯定不是看看书就能明白的, 必须结合实践. `GOF`有`23`种设计模式, 总是想着集大成, 但是确实是非常非常困难. 按照以往的思路呢, 应该就是先简单实现一下, 看看效果如何, 但是前两天并没有这么干.  
- 分析一下原因所在吧. 首先, 我一上来看的是工厂模式, 抽象工厂模式, 自己的实际问题是在`cpu`内部建模问题. 刚开始感觉可以套这个模式, 虽然能写出来, 却总感觉十分奇怪. 于是就陷在这里了:后面明明还有其它`22`种模式, 却只想先搞明白这种, 并且应用在它不一定适合的地方. 另外, 以为自己懂了抽象工厂模式, 但现在来看的话, 实际上并不懂.  
- 后面就找视频啊, `github`上找例子啊, 等等. 最终还是在`github`上找到了一个比较好的例子, 日本老哥写的. 确实不错. 我自己先整体改了改, 又按照自己的思想写了写, 才比较彻底地明白了抽象工厂模式. 它的例子几乎都是`web`开发层面的, 比较贴合实际生活, 而我自己呢, 更偏向于底层, 需要高度抽象化思维. 但是目前来看, 仍不具备这种思维, 还是按照传统的思想来考虑的.  
- 根据个人学习哲学来看, 这些都是无所谓的, 关键还是要多应用的. 但是从`web`日常思维抽象->底层高度抽象思维, 需要一定的转变过程, 不是说看看几个例子就会了的那种, 必然需要平时更多的底层高度抽象模式实践应用.  
- 现在来看呢, 还是先将`GOF`的`23`种设计模式学完再说, 应用层面还是以`web`为主. 等后续对设计模式有了一定理解后, 再进行思维的转变:像底层高度抽象思维的转变, 这样可能会好很多.  
- 当然, `23`种设计模式, 一口气学完肯定不现实的, 慢慢地学就行. 比如一天学一个, 但是一定要及时巩固复习. 当然, 这种复习肯定不是说去背某个模式, 意义不是很大, 我觉得可以换一个实际应用场景, 再自己建模思考, 并且评价这个模式在这个应用场景的效果如何. 不必非得用代码实现, 自己脑子里有一个模型就足够了.  
- 另外, 我觉得, 对于底层层面的建模, 并不是说会了建模就一定可以, 底层的相关知识也需要有自己一定的理解, 否则二者不在同一水平面上, 即使建模水平再高, 缺乏底层相关知识, 也是无法设计好的.  
- 对了, 再说另外一个问题. 本来还是想写`os`的, 但是为了更好地抽象模拟`cpu`内部运行态, 经过综合考虑, 打算用`python`模拟. 这是我最初的需求. 后续发现自己并不能很好地建模, 虽然写完了, 也能运行, 但是整体结构我并不满意. 后续又看了`ai`的设计, 其实整体设计思路非常好, 而且能直接拿来用. 但是我并不喜欢这样, 我想自己能独自设计. 这就有了上面的重新分析面向对象设计, 并思考对应模式的原因. 可是我最初的目的, 仅仅是做一个模拟, 本身还是要学习`os`的, 现在却又转向去学另一个东西了. 我不知道这么做是否正确, 但是随着"工具"越来越多, 效率/速率会逐步上升. 目标是学`A`, 但是兜兜转转没有学`A`, 转而去学`B`去了. 这可以是当前情况的简述了. 看`B`的难易程度吧, 简单的话, 学会`B`再弄`A`, 无可厚非. 难的话, 只能拉长战线, 间接性学`B`, 主要目标还是学`A`, 这是比较好的解决方案. 当下情况就是后者. 
- 但是以我的个性, 非得弄懂才罢休, 哈哈. 目前也正在尝试着转换这一思想. 
- 刚才看了之前有的一本电子书, 《面向对象是怎样工作的》. 刚看完第三章吧, 最关键内容还没有看到, 但是总感觉似乎能解决我的问题. 不过我的问题是什么呢? 很难意会. 尤其是设计类的这些问题, 很难讲明白. 
- 想了想, 没有好的参考. 我目前分析过的库的话, 是`python`的`manim`库, 面向用户层面的, 不难理解, 但是底层实现层面, 感觉十分混乱, 不知从何入手. 另一个是`C`的嵌入式的标准库. 但是这是非面向对象语言, 更多的是函数式编程, 有一定的面向对象角度学习的参考价值, 但是并不是很大. 书上的例子又过于虚化, 很容易理解, 但是很难真实理解. 想了想, 还是因为缺少实际应用. 后续怎么办呢? 还是先将基本设计模式学完, 再谈下一步吧. 慢慢来, 不着急. 
- 太急了. 拉长战线吧. 一天学一个模式, 虽然很容易理解, 但是其实没啥用, 理解了不代表会用. 多拿出来时间思考模式应用场景比较好, 这样会建立更深入的理解. 
